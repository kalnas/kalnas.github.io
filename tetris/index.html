<!-- JavaScript Tetris -- Kal Nasser -->
<!DOCTYPE html>
<html>
    <head>
        <title>Tetris</title>
    </head>
<body>

<div>
    <canvas width="250" height="500" style="border: solid black;" id="myCanvas">
        This browser does not support the HTML5 canvas tag.
    </canvas>

    <br>
    <div id="status">n: play, arrows: control<br> space: pause/resume, ctrl: drop</div>
    <div id="lines">0 lines</div>
</div>

<script>

////////////////////// CLASS: Piece ////////////////////////////////
class Piece {
    static SHAPE_DEFS = [
        { // J
            color: 'red',
            blocks: [ {x: 0, y: 3}, {x: 1, y: 3}, {x: 1, y: 4}, {x: 1, y: 5} ]
        },
        { // L
            color: 'blue',
            blocks: [ {x: 1, y: 3}, {x: 1, y: 4}, {x: 1, y: 5}, {x: 0, y: 5} ]
        },
        { // I
            color: 'gray',
            blocks: [ {x: 0, y: 3}, {x: 0, y: 4}, {x: 0, y: 5}, {x: 0, y: 6} ]
        },
        { // S
            color: 'green',
            blocks: [ {x: 1, y: 3}, {x: 1, y: 4}, {x: 0, y: 4}, {x: 0, y: 5} ]
        },
        { // Z
            color: 'yellow',
            blocks: [ {x: 0, y: 3}, {x: 0, y: 4}, {x: 1, y: 4}, {x: 1, y: 5} ]
        },
        { // O
            color: 'orange',
            blocks: [ {x: 0, y: 3}, {x: 1, y: 3}, {x: 0, y: 4}, {x: 1, y: 4} ],
            nonRotatable: true
        },
        { // W
            color: 'brown',
            blocks: [ {x: 1, y: 3}, {x: 1, y: 4}, {x: 0, y: 4}, {x: 1, y: 5} ]
        }        
    ];

    constructor(prev, deltaX, deltaY, rotated) {
        if (!prev) { // new, random piece
            const shapeIdx = Math.floor( Math.random() * 7 );
            this.allowRotation = !Piece.SHAPE_DEFS[shapeIdx].nonRotatable;
            this.color = Piece.SHAPE_DEFS[shapeIdx].color;
            this.blocks = Piece.SHAPE_DEFS[shapeIdx].blocks;
        } else { // clone a previous piece
            this.allowRotation = prev.allowRotation;
            this.color = prev.color;
            this.blocks = prev.blocks.map((block) => ({x: block.x + deltaX, y: block.y + deltaY}));

            if (rotated && this.allowRotation) {
                for (let i = 0; i < 4; i++) {
                    this.blocks[i] = {
                        y: prev.blocks[2].y - (prev.blocks[2].x - prev.blocks[i].x) * -1, 
                        x: prev.blocks[2].x - (prev.blocks[2].y - prev.blocks[i].y)
                    };
                }
            }
        }
    }
}

////////////////////// CLASS: Board ////////////////////////////////
class Board {
    static BLOCK_SIZE = 25;
    static NUM_COLUMNS = 10;
    static NUM_ROWS = 20;
    static BACKGROUND = 'white';

    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.board = 
            Array(Board.NUM_ROWS).fill().map(() => Array(Board.NUM_COLUMNS).fill(Board.BACKGROUND));
        this.currPiece = null;
        this.paused = false;

        // event hooks
        this.gameOver = function() {};
        this.linesCleared = function(num) {};
        this.gamePaused = function() {};
        this.gameResumed = function() {};
        this.newGame = function() {};
    }
   
    drawBoard() {    
        for(let y = 0; y < Board.NUM_COLUMNS; y++) {
            const yLoc = y * Board.BLOCK_SIZE;
            for(let x = 0; x < Board.NUM_ROWS; x++) {
                const xLoc = x * Board.BLOCK_SIZE;
                this.ctx.fillStyle = this.board[x][y];
                this.ctx.fillRect(yLoc, xLoc, Board.BLOCK_SIZE, Board.BLOCK_SIZE);
                
                if (this.board[x][y] != Board.BACKGROUND) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = 'black';
                    this.ctx.moveTo(yLoc + 1, xLoc + Board.BLOCK_SIZE - 1);
                    this.ctx.lineTo(yLoc + 1, xLoc + 1);
                    this.ctx.lineTo(yLoc + Board.BLOCK_SIZE - 1, xLoc + 1);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = 'gray';
                    this.ctx.moveTo(yLoc + Board.BLOCK_SIZE - 1, xLoc + 1);
                    this.ctx.lineTo(yLoc + Board.BLOCK_SIZE - 1, xLoc + Board.BLOCK_SIZE - 1);
                    this.ctx.lineTo(yLoc + 1, xLoc + Board.BLOCK_SIZE - 1);
                    this.ctx.stroke();               
                }
            }
        }
    }

    transform(newPiece) {
        // set current piece's colors to background
        this.currPiece?.blocks.filter(block => block.x >= 0).forEach(block => {
            this.board[block.x][block.y] = Board.BACKGROUND;
        });

        const canPlot = newPiece.blocks.every(block =>
            (block.x < Board.NUM_ROWS
                && block.x >= 0 
                && block.y < Board.NUM_COLUMNS 
                && block.y >= 0 // Block is within board limits
                && this.board[block.x][block.y] === Board.BACKGROUND) // and is unoccupied.
            || block.x < 0 // Allow exceeding upper border
        );

        if (canPlot) {
            this.currPiece = newPiece;
        }

        // set piece's colors on the board
        this.currPiece?.blocks.filter(block => block.x >= 0).forEach(block => {
            this.board[block.x][block.y] = newPiece.color;            
        });

        this.drawBoard();
        return canPlot;
    }
   
    clearBoard() {
        this.board.forEach(row => row.fill(Board.BACKGROUND));
        this.drawBoard();
    }
   
   clearCompletedRows() {
        let completedRows = 0;
        for(let x = 0; x < Board.NUM_ROWS; x++) {
            const rowComplete = !this.board[x].includes(Board.BACKGROUND);
            if (rowComplete) {
                completedRows++;
                for(let xi = x; xi >= 0; xi--) {
                    for(let yi = 0; yi < Board.NUM_COLUMNS; yi++) {
                        this.board[xi][yi] = xi > 0 ? this.board[xi - 1][yi] : Board.BACKGROUND;
                    }
                }
            }
        }

        this.drawBoard();      
        return completedRows;
    }

    moveDown() {
        return this.transform(new Piece(this.currPiece, 1, 0));
    }
   
    moveLeft() {
        return this.transform(new Piece(this.currPiece, 0, -1));
    }

    moveRight() {
        return this.transform(new Piece(this.currPiece, 0, 1));        
    }

    rotate() {
        return this.transform(new Piece(this.currPiece, 0, 0, true));
    }    
      
    tick() {
        if (this.paused) {
            return;
        }

        if (!this.moveDown()) { // If we can't move down any more,
            const completedRows = this.clearCompletedRows(); // clear completed rows if any,
            this.linesCleared(completedRows);
            this.currPiece = null; // then release current piece.
            if (!this.transform(new Piece())) { // and make a new one..
                this.gameOver(); // If we can't make a new one, game is over
                return;
            }            
        }        
      
        setTimeout(() => {
            this.tick();
        }, 500);      
    }
   
    drop() {
        while(this.moveDown()) {
            // drop all the way
        }
    }
   
    start() {
        this.newGame();
		this.clearBoard();
		this.tick();
    }
   
    pauseResume() {
        this.paused = !this.paused;
        if (this.paused) {
            this.gamePaused();
        } else {
            this.gameResumed();
            this.tick();
        }
    }

    command(e) {
        if (e.which === 78 && !this.currPiece) {
            this.start();            
        } else if (this.currPiece) {
            switch(e.which) {
                case 37:
                    this.moveLeft();
                    break;
                case 38:
                    this.rotate();
                    break;
                case 39:
                    this.moveRight();
                    break;
                case 40:
                    this.moveDown();               
                    break;
                case 17:
                    this.drop();
                    break;
                case 32:
                    this.pauseResume();
                    break;
            }
        }
    }
} 


////////////////////// Main ////////////////////////////////

let brd = new Board(document.getElementById('myCanvas'));

brd.gameOver = function() {
    document.getElementById('status').innerHTML = 'Game Over';
}

let num = 0;
brd.linesCleared = function(n) {
    document.getElementById('lines').innerHTML = (num += n) + ' lines.';
}

brd.gamePaused = function() {
    document.getElementById('status').innerHTML = 'Paused';
}

brd.gameResumed = function() {
    document.getElementById('status').innerHTML = 'Playing';
}

brd.newGame = function() {
    document.getElementById('lines').innerHTML = '0 lines.';
    document.getElementById('status').innerHTML = 'Playing';
}

window.onkeydown = function(e) {
    brd.command(e);
}

</script>

</body>
</html>
