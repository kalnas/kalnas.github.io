<!DOCTYPE html>
<html>
<head>
<title>Space Invaders</title>
</head>
<body>

<canvas width="1000" height="600" style="border: solid black;" id="myCanvas"></canvas>
<div><b>[n]ew game<br>[space] to pause/resume<br>&lArr; / &rArr; to move<br>&uArr; to fire</b></div>

<script>

// ============  Player class =====================================================
class Player {
  constructor(image, left, top, width, height, worldWidth, direction, speed) {
    this.image = image;
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
    this.currDirection = direction;
    this.worldWidth = worldWidth;
    this.speed = speed; // pixels per ms
  }

  draw(ctx) {
    ctx.drawImage(this.image, this.left, this.top, 100, 100);
  }

  switchDirection() {
    this.currDirection *= -1;
  }

  move(timePassed, direction) {
    // no direction, maintain current momentum
    if (!direction) { 
      if (Math.random() > 0.99) { // occasionally change direction
        this.switchDirection();
      }

      direction = this.currDirection;
    }

    if ( (this.left > 0 && direction < 0) 
      || (this.left + this.width < this.worldWidth && direction > 0) ) {
      this.left += (direction * this.speed * timePassed);
    } else {
      this.switchDirection(); // bumped into border
    }
  }
}


// ============== Missile class ======================
// Each missile is aware of the locations of all characters
// in order to detect when it collides with them.
class Missile {
  constructor(left, top, direction, player, opponent1, opponent2, viewHeight, reportHit) {
    this.x = left;
    this.y = top;
    this.direction = direction;
    this.exploded = false;
    this.player = player;
    this.opponent1 = opponent1;
    this.opponent2 = opponent2;
    this.viewHeight = viewHeight;
    this.reportHit = reportHit;
  }

  collisionDetected(character) {
    return (this.y >= character.top)
      && (this.y <= character.top + character.height)
      && (this.x >= character.left)
      && (this.x <= character.left + character.width);    
  }

  move(timePassed) {
    // constant speed: .5 px / 1 ms
    this.y -= (this.direction * timePassed * .5);

    // Hitting world's borders
    if ((this.direction == 1 && this.y < 1) || (this.direction == -1 && this.y + 16 > this.viewHeight)) {
      return false;
    }

    // Hitting intended targets...
    if (this.direction == 1 && (this.collisionDetected(this.opponent1) || this.collisionDetected(this.opponent2))) {
      this.explode();
      return true;
    }

    if (this.direction == -1 && this.collisionDetected(this.player)) {
      this.explode();
      return true;
    }

    return true;      
  }

  explode() {
    this.exploded = true;
    this.reportHit && this.reportHit();
    this.reportHit = null;
  }

  draw(ctx) {
    ctx.beginPath();

    if (!this.exploded) {
      ctx.arc(this.x, this.y, 15, 0, 2 * Math.PI);
      ctx.fillStyle = "red";
    } else {
      ctx.arc(this.x, this.y, 50, 0, 2 * Math.PI);
      let grd = ctx.createRadialGradient(this.x, this.y, 20, this.x, this.y, 70);
      grd.addColorStop(0, "red");
      grd.addColorStop(1, "white");
      ctx.fillStyle = grd;     
    }

    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "white";
   }
}



// =========================== Space ==========================================
// This is just the background of stars in the sky.
class Space {
  constructor(worldWidth, worldHeight) {
    this.worldWidth = worldWidth;
    this.worldHeight = worldHeight;
    this.row = [];
    this.stars = [];

    for (let y = 0; y < this.worldHeight; y++) {
      this.newRow();
      for (let x = 0; x < this.worldWidth; x++) {
        this.stars[x] = this.stars[x] || [];
        this.stars[x][y] = this.row[x];
      }
    }
  }

  newRow() {
    for (let x = 0; x < this.worldWidth; x++) {
      this.row[x] = Math.random() > 0.999;
    }
  }

  scroll() {
    for (let y = 0; y < this.worldHeight - 1; y++) {
      for (let x = 0; x < this.worldWidth; x++) {
        this.stars[x][y] = this.stars[x][y + 1];
      }
    }

    this.newRow();
    for (let x = 0; x < this.worldWidth; x++) {
      this.stars[x][this.worldHeight - 1] = this.row[x];
    }
  }

  draw(ctx) {
    for (let x = 0; x < this.worldWidth; x++) {
      for (let y = 0; y < this.worldHeight; y++) {
        if (this.stars[x][y]) {
          ctx.fillRect(x, y, 1, 1);
        }
      }
    }
  }
}


// ========================= World ========================================
// This tracks all entities (characters, missiles), advances the frames
// and processes user input.
class World {
  constructor(canvas, playerImageSrc, opponent1ImageSrc, opponent2ImageSrc) {
    this.ctx = canvas.getContext('2d');
    this.canvas = canvas;
    this.viewWidth = canvas.clientWidth;
    this.viewHeight = canvas.clientHeight;

    this.space = new Space(this.viewWidth, this.viewHeight);
    this.playerDirection = 0;

    let playerImage = new Image(100, 100);
    playerImage.src = playerImageSrc;

    let opponent1Image = new Image(100, 100);
    opponent1Image.src = opponent1ImageSrc;

    let opponent2Image = new Image(100, 100);
    opponent2Image.src = opponent2ImageSrc;

    this.player = new Player(
      playerImage,
      (this.viewWidth / 2) - (playerImage.width / 2), 
      this.viewHeight - playerImage.height - 30,
      playerImage.width + 30,
      playerImage.height + 30,
      this.viewWidth,
      0,
      0.5);

    this.opponent1 = new Player(
      opponent1Image,
      this.player.left + 100,
      0,
      opponent1Image.width + 30,
      opponent1Image.height + 30,
      this.viewWidth,
      1,
      0.2);

    this.opponent2 = new Player(
      opponent2Image,
      this.player.left - 100,
      0,
      opponent2Image.width + 30,
      opponent2Image.height + 30,
      this.viewWidth,
      -1,
      0.2);

    this.playerMissiles = [];
    this.opponentMissiles = [];
    this.paused = true;
    this.timeoutId = 0;
    this.animationFrameId = 0;

    this.playerScore = 0;
    this.opponentScore = 0;
  }

  addMissile(left, top, direction, character) {
    if (character == this.player) {
      this.playerMissiles.push(
        new Missile(
          left, top, direction, this.player, this.opponent1, this.opponent2, this.viewHeight, () => { this.playerScore++; }));
    } else {
      this.opponentMissiles.push(
        new Missile(
          left, top, direction, this.player, this.opponent1, this.opponent2, this.viewHeight, () => { this.opponentScore++; }));
    }
  }

  draw() {
    this.animationFrameId = requestAnimationFrame(() => this.draw());

    this.ctx.fillStyle = "#000000";
    this.ctx.fillRect(0, 0, this.viewWidth, this.viewHeight);
    this.ctx.fillStyle = "#FFFFFF";

    this.space.draw(this.ctx);		
    this.player.draw(this.ctx);
    this.opponent1.draw(this.ctx);
    this.opponent2.draw(this.ctx);

    for (let i = 0; i < this.playerMissiles.length; i++) {
      this.playerMissiles[i].draw(this.ctx);
    }

    for (let i = 0; i < this.opponentMissiles.length; i++) {
      this.opponentMissiles[i].draw(this.ctx);
    }

    this.ctx.font = "20px Courier New";
    this.ctx.fillText("Player   : " + this.playerScore, 10, this.viewHeight - 50); 
    this.ctx.fillText("Opponents: " + this.opponentScore, 10, this.viewHeight - 30); 
  }

  nextFrame(timeElapsed) {
    this.player.move(timeElapsed, this.playerDirection);
    this.opponent1.move(timeElapsed);
    this.opponent2.move(timeElapsed);

    if (this.opponentMissiles.length < 4 && Math.random() > 0.99)
      this.addMissile(this.opponent1.left + this.opponent1.width / 2, this.opponent1.top + this.opponent1.height, -1, this.opponent1);

    if (this.opponentMissiles.length < 4 && Math.random() > 0.99)
      this.addMissile(this.opponent2.left + this.opponent2.width / 2, this.opponent2.top + this.opponent2.height, -1, this.opponent2);

    this.playerMissiles.forEach((missile, index) => {
      if (!missile.move(timeElapsed)) {
        this.playerMissiles.splice(index, 1);
      }
    });

    this.opponentMissiles.forEach((missile, index) => {
      if (!missile.move(timeElapsed)) {
        this.opponentMissiles.splice(index, 1);
      }
    });

    this.space.scroll();
  }

  tick(lastTick, timeElapsed) {
      let currTick = Date.now();
      timeElapsed = currTick - lastTick;
      this.timeoutId = setTimeout(() => this.tick(currTick, timeElapsed), 5);
      this.nextFrame(timeElapsed);
  };

  keydown(e) {
      switch(e.which) {
         case 37: // left
            this.playerDirection = -1;
            break;
         case 38: // up
            if (this.playerMissiles.length < 3)
               this.addMissile(this.player.left + 50, this.player.top, 1, this.player);
            break;
         case 39: // right
            this.playerDirection = 1;
            break;
         case 78:
            this.tick(Date.now());
            this.draw();
            this.paused = !this.paused;
            break;
         case 32: // space
          if (this.paused) {
            // start/resume
            this.tick(Date.now());
            this.draw();
          } else {
            // pause
            cancelAnimationFrame(this.animationFrameId);
            clearTimeout(this.timeoutId);
          }
          this.paused = !this.paused;
          break;
      }
   }
   
   keyup(e) {
      switch(e.which) {
         case 37:
         case 39:
            this.playerDirection = 0;
      }   
   }  
}


// ================= Set things up ===========================
let world;

window.onkeydown = (e) => {
  if (e.which == 78) {
    const urlParams = new URLSearchParams(window.location.search);
    const root = "./";
    world = new World(
      document.getElementById('myCanvas'),
      urlParams.get('player') ? root + urlParams.get('player') : "smiley1.png",
      urlParams.get('opponent1') ? root + urlParams.get('opponent1') : "smiley1.png",
      urlParams.get('opponent2') ? root + urlParams.get('opponent2') : "smiley1.png")
  }

  world && world.keydown(e);
};

window.onkeyup = (e) => {
  world && world.keyup(e);
};

</script>

</body>
</html>

