<!DOCTYPE html>
<html><head><title>Space Invaders</title></head>

<body>
<canvas width="1000" height="600" style="border: solid black;" id="myCanvas"></canvas>
<div><b>[n]ew game<br>[space] to pause/resume<br>&lArr; / &rArr; to move<br>&uArr; to fire</b></div>

<script>
// ============  Player class =====================================================
class Player {
  constructor(image, left, top, width, height, worldWidth, direction, speed, isCpu) {
    this.image = image;
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
    this.currDirection = direction;
    this.worldWidth = worldWidth;
    this.speed = speed; // pixels per ms
    this.isCpu = isCpu;
  }

  draw(ctx) {
    ctx.drawImage(this.image, this.left, this.top, 100, 100);
  }

  move(timePassed, direction) {
    this.currDirection = direction;

    if (this.isCpu && Math.random() > 0.99) {
      this.currDirection *= -1;      
    }

    if ( (this.left > 0 && this.currDirection == -1) 
      || (this.left + this.width < this.worldWidth && this.currDirection == 1) ) {
      this.left += (this.currDirection * this.speed * timePassed);
    } else {
      this.currDirection *= -1; // bumped into border
    }
  }
}

// ============== Missile class ======================
// Each missile is aware of the locations of all characters
// in order to detect when it collides with them.
class Missile {
  constructor(left, top, direction, players, viewHeight, reportHit, caption) {
    this.left = left;
    this.top = top;
    this.direction = direction;
    this.exploded = false;
    this.players = players;
    this.viewHeight = viewHeight;
    this.reportHit = reportHit;
    this.caption =  caption;
  }

  collided(character) {
    return (this.top >= character.top)
      && (this.top <= character.top + character.height)
      && (this.left >= character.left)
      && (this.left <= character.left + character.width);
  }

  move(timePassed) {
    this.top += (this.direction * timePassed * 0.4);

    // Reaching world's borders
    if (this.top < 1 || this.top + 16 > this.viewHeight) {
      return false;
    }

    for (let i = 0; i < this.players.length; i++) {
      if (this.collided(this.players[i])) {
        this.exploded = true;
        break;
      }
    }

    if (this.exploded && this.reportHit) {
      this.reportHit();
      this.reportHit = null;
    }

    return true;      
  }

  draw(ctx) {
    ctx.beginPath();

    if (!this.exploded) {
      ctx.arc(this.left, this.top, 15, 0, 2 * Math.PI);
      ctx.fillStyle = "red";
    } else {
      ctx.arc(this.left, this.top, 50, 0, 2 * Math.PI);
      let grd = ctx.createRadialGradient(this.left, this.top, 20, this.left, this.top, 70);
      grd.addColorStop(0, "red");
      grd.addColorStop(1, "white");
      ctx.fillStyle = grd;     
    }

    ctx.fill();

    if (this.caption) {
      ctx.fillStyle = "white";
      ctx.fillText(this.caption, this.left - 10, this.top + 30);
    }

    ctx.stroke();
   }
}

// =========================== Space ==========================================
// This is just the background of stars in the sky.
class Space {
  constructor(worldWidth, worldHeight) {
    this.worldWidth = worldWidth;
    this.worldHeight = worldHeight;    
    this.stars = [];

    for (let row = 0; row < this.worldHeight; row++) {
      for (let col = 0; col < this.worldWidth; col++) {
        this.stars[row] ||= [];
        this.stars[row][col] = this.randomStar();
      }
    }
  }

  randomStar() {
    return Math.random() > 0.9995;
  }

  scroll() {
    // Shift all star rows up, and add a new one at the bottom.
    for (let row = 0; row < this.worldHeight - 1; row++) {
      for (let col = 0; col < this.worldWidth; col++) {
        this.stars[row][col] = this.stars[row + 1][col]
      }
    }
    
    for (let col = 0; col < this.worldWidth; col++) {
      this.stars[this.worldHeight - 1][col] = this.randomStar();
    }
  }

  draw(ctx) {
    ctx.fillStyle = "white";
    for (let col = 0; col < this.worldWidth; col++) {
      for (let row = 0; row < this.worldHeight; row++) {
        if (this.stars[row][col]) {
          ctx.fillRect(col, row, 1, 1);
        }
      }
    }
  }
}


// ========================= World ========================================
// This tracks all entities (characters, missiles), advances the frames
// and processes user input.
class World {
  constructor(canvas, playerImageSrc, opponent1ImageSrc, opponent2ImageSrc, captionUp, captionDown) {
    this.ctx = canvas.getContext('2d');
    this.ctx.font = "20px Courier New";
    this.canvas = canvas;
    this.viewWidth = canvas.clientWidth;
    this.viewHeight = canvas.clientHeight;
    this.captionUp = captionUp;
    this.captionDown = captionDown;

    this.space = new Space(this.viewWidth, this.viewHeight);
    this.playerDirection = 0;

    let imageWidth = 100;
    let imageHeight = 100;
    let createImage = (imageSrc) => {
      let img = new Image(imageWidth, imageHeight);
      img.src = imageSrc;
      return img;
    };

    let playerLeft = (this.viewWidth / 2) - (imageWidth / 2);
    this.players = [
      new Player(
        createImage(playerImageSrc),
        playerLeft, 
        this.viewHeight - imageHeight - 30,
        imageWidth + 30,
        imageHeight + 30,
        this.viewWidth,
        0,
        0.5,
        /*isCpu=*/false),      
      new Player(
        createImage(opponent1ImageSrc),
        playerLeft + 100,
        0,
        imageWidth + 30,
        imageHeight + 30,
        this.viewWidth,
        1,
        0.3,
        /*isCpu=*/true),
      new Player(
        createImage(opponent2ImageSrc),
        playerLeft - 100,
        0,
        imageWidth + 30,
        imageHeight + 30,
        this.viewWidth,
        -1,
        0.3,
        /*isCpu=*/true)
    ];

    this.opponents = this.players.filter(player => player.isCpu);
    this.playerMissiles = [];
    this.opponentMissiles = [];
    this.paused = true;
    this.timeoutId = 0;
    this.animationFrameId = 0;
    this.playerScore = 0;
    this.opponentScore = 0;
  }

  getMissile(left, top, direction, character) {
    let callBack = character.isCpu 
      ? () => { this.opponentScore++; } 
      : () => { this.playerScore++; };
    let caption = Math.random() > 0.66 // randomize when to show the caption
      && (character.isCpu ? this.captionDown : this.captionUp);
    return new Missile(
      left, top, direction, this.players, this.viewHeight, callBack, caption);
  }

  draw() {
    this.animationFrameId = requestAnimationFrame(() => this.draw());

    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, this.viewWidth, this.viewHeight);    

    this.space.draw(this.ctx);
    for (let player of this.players) {
      player.draw(this.ctx);
    }

    for (let i = 0; i < this.playerMissiles.length; i++) {
      this.playerMissiles[i].draw(this.ctx);
    }

    for (let i = 0; i < this.opponentMissiles.length; i++) {
      this.opponentMissiles[i].draw(this.ctx);
    }

    this.ctx.fillStyle = "white";    
    this.ctx.fillText("Player   : " + this.playerScore, 10, this.viewHeight - 50); 
    this.ctx.fillText("Opponents: " + this.opponentScore, 10, this.viewHeight - 30); 
  }

  nextFrame(timeElapsed) {
    for (let player of this.players) {
      if (player.isCpu) {
        player.move(timeElapsed, player.currDirection);        
      } else {
        player.move(timeElapsed, this.playerDirection);
      }
    }

    for (let opponent of this.opponents) {
      if (this.opponentMissiles.length < 5 && Math.random() > 0.99) {
        this.opponentMissiles.push(
              this.getMissile(opponent.left + opponent.width / 2,
                              opponent.top + opponent.height,
                              1,
                              opponent));
      }
    }

    this.playerMissiles.forEach((missile, index) => {
      if (!missile.move(timeElapsed)) {
        this.playerMissiles.splice(index, 1);
      }
    });

    this.opponentMissiles.forEach((missile, index) => {
      if (!missile.move(timeElapsed)) {
        this.opponentMissiles.splice(index, 1);
      }
    });

    this.space.scroll();
  }

  tick(lastTick, timeElapsed) {
      let currTick = Date.now();
      timeElapsed = currTick - lastTick;
      this.timeoutId = setTimeout(() => this.tick(currTick, timeElapsed), 5);
      this.nextFrame(timeElapsed);
  };

  keydown(e) {
      switch(e.which) {
         case 37: // left
            this.playerDirection = -1;
            break;
         case 38: // up
            // players[0] == human player
            if (this.playerMissiles.length < 2)
               this.playerMissiles.push(
                this.getMissile(this.players[0].left + 50,
                                this.players[0].top,
                                -1,
                                this.players[0]));               
            break;
         case 39: // right
            this.playerDirection = 1;
            break;
         case 78: // [n]ew
            this.tick(Date.now());
            this.draw();
            this.paused = !this.paused;
            break;
         case 32: // space
          if (this.paused) {
            // start/resume
            this.tick(Date.now());
            this.draw();
          } else {
            // pause
            cancelAnimationFrame(this.animationFrameId);
            clearTimeout(this.timeoutId);
          }
          this.paused = !this.paused;
          break;
      }
   }
   
   keyup(e) {
      switch(e.which) {
         case 37:
         case 39:
            this.playerDirection = 0;
      }   
   }  
}


// ================= Set things up ===========================
let world;

window.onkeydown = (e) => {
  if (e.which == 78) {
    const urlParams = new URLSearchParams(window.location.search);
    const root = "./";

    if (world) {
      clearTimeout(world.timeoutId);
      cancelAnimationFrame(world.animationFrameId);
    }

    world = new World(
      document.getElementById('myCanvas'),
      urlParams.get('player') ? root + urlParams.get('player') : "smiley1.png",
      urlParams.get('opponent1') ? root + urlParams.get('opponent1') : "smiley1.png",
      urlParams.get('opponent2') ? root + urlParams.get('opponent2') : "smiley1.png",
      urlParams.get('captionUp'),
      urlParams.get('captionDown'))
  }

  world && world.keydown(e);
};

window.onkeyup = (e) => {
  world && world.keyup(e);
};
</script>
</body>
</html>

